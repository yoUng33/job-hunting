# 540. Single Element in a Sorted Array
<https://leetcode.com/problems/single-element-in-a-sorted-array/>
Medium

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.

Follow up: Your solution should run in O(log n) time and O(1) space.

 

**Example 1:**

    Input: nums = [1,1,2,3,3,4,4,8,8]
    Output: 2

**Example 2:**

    Input: nums = [3,3,7,7,10,11,11]
    Output: 10
 

**Constraints:**

    * 1 <= nums.length <= 10^5
    * 0 <= nums[i] <= 10^5


## Explanation: 
由于有了时间复杂度的限制，需要为O(logn)，而数组又是有序的，不难想到要用二分搜索法来做。二分搜索法的难点在于折半了以后，如何判断将要去哪个分支继续搜索，而这道题确实判断条件不明显，比如下面两个例子：

1  1  2  2  3

1  2  2  3  3

这两个例子初始化的时候left=0, right=4一样，mid算出来也一样为2，但是他们要去的方向不同，如何区分出来呢？仔细观察我们可以发现，如果当前数字出现两次的话，我们可以通过数组的长度跟当前位置的关系，计算出右边和当前数字不同的数字的总个数，如果是偶数个，说明落单数左半边，反之则在右半边。



## Binary Search Solution: 
将right缩小了一倍，但是在比较的时候，是比较mid*2和mid*2+1的关系的，这样还是能正确的比较原本应该相等的两个小伙伴的值的。

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n=nums.length, lo=0, hi=n/2;
        while (lo < hi) {
            int m = (lo + hi) / 2;
            if (nums[2*m]!=nums[2*m+1]) hi = m;
            else lo = m+1;
        }
        return nums[2*lo];
    }
}
```