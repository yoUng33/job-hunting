# 1283. Find the Smallest Divisor Given a Threshold
<https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/>
Medium

Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).

It is guaranteed that there will be an answer.

 

**Example 1:**

Input: nums = [1,2,5,9], threshold = 6
Output: 5
Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
**Example 2:**

Input: nums = [44,22,33,11,1], threshold = 5
Output: 44
**Example 3:**

Input: nums = [21212,10101,12121], threshold = 1000000
Output: 1
**Example 4:**

Input: nums = [2,3,5,7,11], threshold = 11
Output: 3
 
**Constraints:**

* 1 <= nums.length <= 5 * 104
* 1 <= nums[i] <= 106
* nums.length <= threshold <= 106

Related Topics: Array; Binary Search
## Explanation:
给出一个数组，求一个最小除数。数组中所有的数字除以除数后，商的和要小于等于 threshold。

## Binary Search Solution: 
用二分法查找。题目可以改成找到第一个商的和不大于目标值的，就可以转换成二分法找第一个不大于目标值的。左边从1开始，右边从nums[i]最大值 1e6 开始。每次循环找到 mid，把商求和 sum。因为商是向上求整，公式: (divider+divsor-1)/divsor。如果 sum <= threshold, 说明divisor足够大，可以继续缩小 right = mid。否则 left = mid + 1。

```java
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int left = 1, right = (int)1e6;
        while(left < right){
            int mid = left + (right - left)/2;
            int sum = 0;
            for(int n : nums){
                sum += (n + mid -1)/mid;
            }
            if(sum <= threshold){
                right = mid;
            }else{
                left = mid+1;
            }

        }
        return left;
    }
}
```