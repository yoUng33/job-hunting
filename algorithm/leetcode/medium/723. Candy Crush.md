# 723. Candy Crush
<https://leetcode.com/problems/candy-crush/>
Medium

This question is about implementing a basic elimination algorithm for Candy Crush.

Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:

If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.
After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)
After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.
If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.
You need to perform the above rules until the board becomes stable, then return the current board.

 

**Example 1:**
![alt text](../resources/723_q1.png)
    Input:
    board =
    [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]

    Output:
    [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]

**Example 2:**
    Input: board = [[1,3,5,5,2],[3,4,3,3,1],[3,2,4,5,2],[2,4,4,5,5],[1,4,4,1,1]]
    Output: [[1,3,0,0,0],[3,4,0,5,2],[3,2,0,3,1],[2,4,0,5,2],[1,4,3,1,1]]


**Constraints:**

m == board.length
n == board[i].length
3 <= m, n <= 50
1 <= board[i][j] <= 2000

Related Topics: Array; Two Pointers; Matrix; Simulation

## Explanation:
这道题就是糖果消消乐，这道题一次消除 table 中所有可消除的糖果，然后才下落，形成新的 table，这样消除后得到的结果就是统一的了，这样也大大的降低了难度。

## Ad-hoc Solution:
每个糖果单独检查其是否能被消除，然后把所有能被删除的糖果都标记出来统一删除，然后在下落糖果，然后再次查找，直到无法找出能够消除的糖果时达到稳定状态。设可以被消除的糖果的值为负。分别检查水平和垂直方向上是否有可以消除的糖果并标记。注意处理越界和已标记的糖果。同时用 shouldContinue 来记录是否有消除。有的话需要进行第二轮。然后进行落下，把要消除的位置滚到上面。用 r 记录要消除的位置，把下个不消除的位置赋值给 r 的位置。然后从 r 开始把上面的已经消除的位置赋值为0。


Time: O(n^2)
Space: O(1)

```java
class Solution {
    public int[][] candyCrush(int[][] board) {
        int m = board.length, n = board[0].length;
        boolean shouldContinue = false;
        // Crush horizontally
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n-2; j++){
                int v = Math.abs(board[i][j]);
                if(v > 0 && v == Math.abs(board[i][j+1]) && v == Math.abs(board[i][j+2])){
                    board[i][j] = board[i][j+1] = board[i][j+2] = -v;
                    shouldContinue = true;
                }
            }
        }
        // Crush vertically
        for(int i = 0; i<m-2; i++){
            for(int j = 0; j<n; j++){
                int v = Math.abs(board[i][j]);
                if(v > 0 && v == Math.abs(board[i+1][j]) && v == Math.abs(board[i+2][j])){
                    board[i][j] = board[i + 1][j] = board[i + 2][j] = -v;
                    shouldContinue = true;
                }
            }
        }
        // Drop vertically
        for(int j = 0; j<n; j++){
            int r = m-1; //record row to delete
            for(int i = m-1; i>=0; i--){
                if(board[i][j] >= 0){
                    board[r--][j] = board[i][j];
                }
            }
            for (int i = r; i >= 0; i--) {
              board[i][j] = 0;
            }
        }
        return shouldContinue ? candyCrush(board) : board;
    }
}
```
