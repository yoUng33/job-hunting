# 322. Coin Change
<https://leetcode.com/problems/coin-change/>
Medium

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

**Example 1:**

    Input: coins = [1, 2, 5], amount = 11
    Output: 3 
    Explanation: 11 = 5 + 5 + 1

**Example 2:**

    Input: coins = [2], amount = 3
    Output: -1

**Note:**
You may assume that you have an infinite number of each kind of coin.

Related Topics: Dynamic Programming

Similar Questions: 
* Medium [Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/)

## Explaination: 
对于求极值问题，主要考虑动态规划 Dynamic Programming 来做，好处是保留了一些中间状态的计算值，可以避免大量的重复计算。
## DP Bottom up Solution: 
我们维护一个一维动态数组 dp，其中 dp[i] 表示钱数为i时的最小硬币数的找零，注意由于数组是从0开始的，所以要多申请一位，数组大小为 amount+1，这样最终结果就可以保存在 dp[amount] 中了。初始化 dp[0] = 0，因为目标值若为0时，就不需要硬币了。其他值可以初始化是 amount+1，为啥呢？因为最小的硬币是1，所以 amount 最多需要 amount 个硬币，amount+1 也就相当于当前的最大值了，注意这里不能用整型最大值来初始化，因为在后面的状态转移方程有加1的操作，有可能会溢出，除非你先减个1，这样还不如直接用 amount+1 舒服呢。好，接下来就是要找状态转移方程了，没思路？不要紧！回归例子1，假设我取了一个值为5的硬币，那么由于目标值是 11，所以是不是假如我们知道 dp[6]，那么就知道了组成 11 的 dp 值了？所以更新 dp[i] 的方法就是遍历每个硬币，如果遍历到的硬币值小于i值（比如不能用值为5的硬币去更新 dp[3]）时，用 dp[i - coins[j]] + 1 来更新 dp[i]，所以状态转移方程为：
dp[i] = min(dp[i], dp[i - coins[j]] + 1);
其中 coins[j] 为第j个硬币，而 i - coins[j] 为钱数i减去其中一个硬币的值，剩余的钱数在 dp 数组中找到值，然后加1和当前 dp 数组中的值做比较，取较小的那个更新 dp 数组。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(coins == null || coins.length == 0 || amount <= 0) return 0;
        int[] dp = new int[amount+1];
        for(int i = 1; i<=amount; i++){
            dp[i] = amount+1;
            for(int j = 0; j<coins.length; j++){
                if(coins[j]<=i) {
                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+1);
                }
            }
        }
        return dp[amount] >= (amount+1)? -1 : dp[amount];
    }
}
```


## DP Top Down Solution: 
迭代的 DP 解法有一个好基友，就是递归+记忆数组的解法。考虑到最后一步，我需要找到 coin 等于剩余值 r = amount - coin[i]。所以对每一步重复相同的步骤，直到 r 等于0或者小于0（结果不存在）。用一个记忆数组 count 来记录达到 i 所需要最小coin的个数。
递归函数中，用变量 min 保存最小结果。先检查 rem 是否为0（找到结果，返回0）或者1（没有结果，返回-1）。如果 count数组中已经有结果，直接返回。然后遍历可选 coins，依次对剩余值 rem - coin 调用递归。如果返回结果不为-1，更新 min。遍历完 coins 数组，更新 count 并返回 min。注意需要检查 min 是否有结果（不是Integer.MAX_VALUE）。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount<1) return 0;
        int[] count = new int[amount+1];
        return helper(coins, amount, count);
    }
    
    private int helper(int[] coins, int rem, int[] count) { // rem: remaining coins after the last step; count[rem]: minimum number of coins to sum up to rem
        if(rem<0) return -1; // not valid
        if(rem == 0) return 0;// complete
        if(count[rem] != 0) return count[rem]; // already computed, so reuse
        int min = Integer.MAX_VALUE;
        for(int coin : coins) {
            int res = helper(coins, rem-coin, count);
            if(res != -1)
                min = Math.min(res+1, min);
        }
        count[rem] = (min==Integer.MAX_VALUE) ? -1 : min;
        return count[rem];
    }
}
```