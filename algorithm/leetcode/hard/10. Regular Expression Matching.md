# 10. Regular Expression Matching
<https://leetcode.com/problems/regular-expression-matching/>
Hard

Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

    '.' Matches any single character.
    '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

**Note:**

    * s could be empty and contains only lowercase letters a-z.
    * p could be empty and contains only lowercase letters a-z, and characters like . or *.

**Example 1:**

    Input:
    s = "aa"
    p = "a"
    Output: false
    Explanation: "a" does not match the entire string "aa".

**Example 2:**

    Input:
    s = "aa"
    p = "a*"
    Output: true
    Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".

**Example 3:**

    Input:
    s = "ab"
    p = ".*"
    Output: true
    Explanation: ".*" means "zero or more (*) of any character (.)".

**Example 4:**

    Input:
    s = "aab"
    p = "c*a*b"
    Output: true
    Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".

**Example 5:**

    Input:
    s = "mississippi"
    p = "mis*is*p*."
    Output: false

Related Topics: String; Dynamic Programming; Backtracking

Similar Questions:  
* Hard [Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)

## Explanation: 
这道求正则表达式匹配的题和那道 Wildcard Matching 的题很类似，不同点在于的意义不同，在之前那道题中，表示可以代替任意个数的字符，而这道题中的表示之前那个字符可以有0个，1个或是多个，就是说，字符串 ab，可以表示b或是 aaab，即a的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归 Recursion 来解。

## DP Solution: 
定义一个二维的 DP 数组，其中 dp[i][j] 表示 s[0,i) 和 p[0,j) 是否 match，然后有下面三种情况: 
  * p[j-1] == '*', 则有两种情况：
      * *前字母是0个，那 s 前 i-1个字符串和 p 前 j-3个字符串匹配，即 dp[i][j-2] == true;
      * *前字符重复至少1次，那 s的i-1字母和p的j-2字母要匹配，或者 p的j-2是.
  * 否则就需要 s的 i-1 和 p的 j-1匹配，或者p的j-1是.
状态转换方程：
    * if p.charAt(j-1) == '*':
      * dp[i][j] = dp[i][j - 2], if p[j - 1] == '*' and the pattern repeats for 0 time;
      * dp[i][j] = dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'), if p[j - 1] == '*' and the pattern repeats for at least 1 time.
    * Otherwise: dp[i][j] = dp[i - 1][j - 1], if p[j - 1] != '*' && (s[i - 1] == p[j - 1] || p[j - 1] == '.');

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean dp[][] = new boolean[m+1][n+1];
        dp[0][0] = true;
        for(int i = 0; i<=m; i++){
            for(int j = 1; j<=n; j++){
                if(p.charAt(j-1) == '*'){
                    dp[i][j] = (dp[i][j-2]) || (i>0 && j>1 && dp[i-1][j] && ((s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')));
                }else{
                    dp[i][j] = i>0 && dp[i-1][j-1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.');
                }
            }
        }
        return dp[m][n];
    }
}
```
## Recursive Solution:  
注意 * 可以代表0个，1个或多个。具体情况如下： 
- 若p为空，若s也为空，返回true，反之返回false。
- 若p的第二个字符为*：
  - 先检查p的第一个字符为0个的情况。对p.substring(2)和s调用递归函数匹配。
  - p重复多次，如果p和s的第一个字符一样(包括p第一个为'.')，那对s.substring(1)和p调用递归函数匹配。
- 若p的第二个字符不为*，若此时s为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        if(p.isEmpty()) return s.isEmpty();
        if(p.length() > 1 && p.charAt(1) == '*'){ // 如果 p 的第二个字符是*, 那*前的字母可以是任意个。
            if(isMatch(s, p.substring(2))) return true; // 检查如果 p *前字母为0个，即*后字符串和 s 匹配。
            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))){ 
                // 检查如果p *前字母为多个，对比s的第一个，如果匹配则继续。
                return isMatch(s.substring(1), p); // 注意p不去除，因为*前字母可以多个。
            }
            return false;
        }else{
            //p的第一个字母不是*，所以必须一一匹配。
            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))){
                return isMatch(s.substring(1), p.substring(1));//检查后面的字符串。
            }
            return false;
        }
    }
}
```
