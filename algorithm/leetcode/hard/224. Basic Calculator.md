# 224. Basic Calculator
<https://leetcode.com/problems/basic-calculator>
Hard

Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.

**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().

**Example 1:**
    Input: "1 + 1"
    Output: 2

**Example 2:**
    Input: " 2-1 + 2 "
    Output: 3

**Example 3:**
    Input: "(1+(4+5+2)-3)+(6+8)"
    Output: 23

**Constraints:**
    * 1 <= s.length <= 3 * 105
    * s consists of digits, '+', '-', '(', ')', and ' '.
    * s represents a valid expression.
    * '+' is not used as a unary operation (i.e., "+1" and "+(2 + 3)" is invalid).
    * '-' could be used as a unary operation (i.e., "-1" and "-(2 + 3)" is valid).
    * There will be no two consecutive operators in the input.
    * Every number and running calculation will fit in a signed 32-bit integer.

Related Topics: Math; String; Stack; Recursion

Similar Questions: 
* Medium [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
* Medium [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)
* Medium [Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)
* Hard [Expression Add Operators](https://leetcode.com/problems/expression-add-operators/)
* Hard [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/)
* Hard [The Score of Students Solving Math Expression](https://leetcode.com/problems/the-score-of-students-solving-math-expression/)

## Explanation:
这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格，没有乘除，那么就没啥计算的优先级之分了。

## One Stack Recursive Generic Solution: 
这个方法适合 Basic Calculator I, II, III。因为每个括号内的公式处理方式一样。所以用一个compute()来处理括号内的公式。用stack来记录上一个数。+-号作为正负号处理。currNum 记录当前数，lastOp 记录上个操作符。
1. 从左往右扫描，遇到数添加到currNum。
2. 遇到操作符，处理lastOp。对于+-，当做正负号处理，把更新后的数字加入stack。对于*/，需要和stack 顶的数字操作并把结果入stack。然后更新lastOp 并重置 currNum。
3. 遇到 ( ，则对括号之后的string递归调用 compute()，用返回结果括号结束后的位置和括号内的值更新 i 和 currNum。
4. 遇到 )和到尾部时 ，对 lastOp 和 currNum 进行计算，把 stack 中的数字和 和 括号后的位置返回。

```java
class Solution {
    public int calculate(String s) {
        return compute(s)[1];
    }
    
    private int[] compute(String s){
        char lastOp = '+'; // 上一个操作符
        int currNum = 0; // record curr number
        Stack<Integer> stack = new Stack();
        for(int i = 0; i<s.length(); i++){
            char c = s.charAt(i);
            if(c == ' ') continue;
            if (Character.isDigit(c)) { 
                currNum = currNum * 10 + Character.getNumericValue(c);
            }else if (c == '+' || c == '-' || c == '*' || c == '/') {
                eval(stack, lastOp, currNum);
                lastOp = c;
                currNum = 0;
            }else if (c == '(') {
                int[] res = compute(s.substring(i+1));
                i += res[0];
                currNum = res[1];
            }else if (c == ')'){
                eval(stack, lastOp, currNum);
                return new int[]{i+1, stack.stream().mapToInt(Integer::intValue).sum()};
            }
        }
        eval(stack, lastOp, currNum);
        return new int[]{s.length(), stack.stream().mapToInt(Integer::intValue).sum()};
    }
    
    private void eval(Stack<Integer> stack, char op, int num){
        switch (op) {
            case '+':
                stack.push(num);
                break;
            case '-':
                stack.push(-num);
                break;
            case '*':
                stack.push(stack.pop() * num);
                break;
            case '/':
                stack.push(stack.pop() / num);
                break;
        }
    }
}
```



