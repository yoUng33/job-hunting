# 57. Insert Interval
<https://leetcode.com/problems/insert-interval/>
Hard

Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

**Example 1:**

    Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
    Output: [[1,5],[6,9]]

**Example 2:**

    Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
    Output: [[1,2],[3,10],[12,16]]
    Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].

**NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

Related Topics: Array; Sort

Similar Questions: 
* Medium [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
* Hard [Range Module](https://leetcode.com/problems/range-module/)

### Merge and Insert Solution: 
这道题让我们在一系列非重叠的区间中插入一个新的区间，可能还需要和原有的区间合并，可以对给定的区间集进行一个一个的遍历比较，那么会有两种情况，重叠或是不重叠，不重叠的情况最好，直接将新区间插入到对应的位置即可，重叠的情况比较复杂，有时候会有多个重叠，需要更新新区间的范围以便包含所有重叠，之后将新区间加入结果 res，最后将后面的区间再加入结果 res 即可。具体思路是，用一个变量 index 来遍历区间，如果当前 index 的区间的结束位置小于要插入的区间的起始位置的话，说明没有重叠，则将 index 区间加入结果 res 中，然后 index 自增1。直到有 index 越界或有重叠 while 循环退出，然后再用一个 while 循环处理所有重叠的区间，每次用取两个区间起始位置的较小值，和结束位置的较大值来更新要插入的区间 newInterval，然后 index 自增1。直到 index 越界或者没有重叠时 while 循环退出。之后将更新好的新区间加入结果 res，然后将 index 之后的区间再加入结果 res 中即可。

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> result = new ArrayList<>();
        int idx = 0;
        while (idx < intervals.length && intervals[idx][1] < newInterval[0]) {
            result.add(intervals[idx++]);
        }
        while (idx < intervals.length && intervals[idx][0] <= newInterval[1]) {
            newInterval[0] = Math.min(intervals[idx][0], newInterval[0]);
            newInterval[1] = Math.max(intervals[idx][1], newInterval[1]);

            ++idx;
        }
        result.add(newInterval);
        while (idx < intervals.length) {
            result.add(intervals[idx++]);
        }
        return result.toArray(new int[result.size()][]);
    }
}
```

### One for loop Solution
思路跟上面的解法很像，只不过没有用 while 循环，而是使用的是 for 循环，但是思路上没有太大的区别，变量 cur 还是用来记录新区间该插入的位置，稍有不同的地方在于在 for 循环中已经将新区间后面不重叠的区间也加进去了，for 循环结束后就只需要插入新区间即可。

```java
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
         List<int[]> result = new ArrayList<>();
         for(int[] i : intervals){
             if(newInterval == null || i[1] < newInterval[0]){
                 result.add(i);
             }else if(i[0] > newInterval[1]){
                // be carefult the sequence here
                 result.add(newInterval);
                 result.add(i);
                 newInterval = null;
             }else{
                 newInterval[0] = Math.min(newInterval[0], i[0]);//get min
                 newInterval[1] = Math.max(newInterval[1], i[1]);//get max
             }
        }
        if(newInterval != null)
            result.add(newInterval);
        return result.toArray(new int[result.size()][]);
    }
}
```