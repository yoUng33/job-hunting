# 233. Number of Digit One
<https://leetcode.com/problems/number-of-digit-one/>
Hard

Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

**Example:**

    Input: 13
    Output: 6 
    Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.

Related Topics: Math

Similar Questions: 
* Easy [Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes/)
* Hard [Digit Count in Range](https://leetcode.com/problems/digit-count-in-range/)


## Mathmetic Solution: 

找出规律，我们就先来列举下所有含1的数字，并每10个统计下个数，如下所示：
```
1的个数           含1的数字                                                                      数字范围
1                   1                                                                           [1, 9]
11                  10  11  12  13  14  15  16  17  18  19                                      [10, 19]
1                   21                                                                          [20, 29]
1                   31                                                                          [30, 39]
1                   41                                                                          [40, 49]
1                   51                                                                          [50, 59]
1                   61                                                                          [60, 69]
1                   71                                                                          [70, 79]
1                   81                                                                          [80, 89]
1                   91                                                                          [90, 99]
11                  100  101  102  103  104  105  106  107  108  109          [100, 109]
21                  110  111  112  113  114  115  116  117  118  119             [110, 119]
11                  120  121  122  123  124  125  126  127  128  129          [120, 129]
...                  ...                                                                                  ...

 

通过上面的列举我们可以发现，100以内的数字，除了10-19之间有11个‘1’之外，其余都只有1个。如果我们不考虑[10, 19]区间上那多出来的10个‘1’的话，那么我们在对任意一个两位数，十位数上的数字(加1)就代表1出现的个数，这时候我们再把多出的10个加上即可。比如56就有(5+1)+10=16个。如何知道是否要加上多出的10个呢，我们就要看十位上的数字是否大于等于2，是的话就要加上多余的10个'1'。那么我们就可以用(x+8)/10来判断一个数是否大于等于2。对于三位数区间 [100, 199] 内的数也是一样，除了[110, 119]之间多出的10个数之外，共21个‘1’，其余的每10个数的区间都只有11个‘1’，所以 [100, 199] 内共有21 + 11 * 9 = 120个‘1’。那么现在想想[0, 999]区间内‘1’的个数怎么求？根据前面的结果，[0, 99] 内共有20个，[100, 199] 内共有120个，而其他每100个数内‘1’的个数也应该符合之前的规律，即也是20个，那么总共就有 120 + 20 * 9 = 300 个‘1’。那么还是可以用相同的方法来判断并累加1的个数。

```java
class Solution {
    public int countDigitOne(int n) {
        int res = 0;
        for (long k = 1; k <= n; k *= 10) {
            long r = n / k, m = n % k;
            res += (r + 8) / 10 * k + (r % 10 == 1 ? m + 1 : 0);
        }
        return res;
    }
}
```

## One Pass Solution: 
总体思想就是分类，先求所有数中个位是 1 的个数，再求十位是 1 的个数，再求百位是 1 的个数...
假设 n = xyzdabc，此时我们求千位是 1 的个数，也就是 d 所在的位置。那么此时有三种情况，

* d == 0，那么千位上 1 的个数就是 xyz * 1000
* d == 1，那么千位上 1 的个数就是 xyz * 1000 + abc + 1
* d > 1，那么千位上 1 的个数就是 xyz * 1000 + 1000

当我们考虑千位是 1 的时候，我们将千位定为 1，也就是 xyz1abc。对于 xyz 的话，可以取 0,1,2...(xyz-1)，也就是 xyz 种可能。当 xyz 固定为上边其中的一个数的时候，abc 可以取 0,1,2...999，也就是 1000 种可能。这样的话，总共就是 xyz*1000 种可能。注意到，我们前三位只取到了 xyz-1，那么如果取 xyz 呢？此时就出现了上边的三种情况，取决于 d 的值。d == 1 的时候，千位刚好是 1，此时 abc 可以取的值就是 0 到 abc ，所以多加了 abc + 1。d > 1 的时候，d 如果取 1，那么 abc 就可以取 0 到 999，此时就多加了 1000。

再看一个具体的例子。

如果n = 4560234
让我们统计一下千位有多少个 1
xyz 可以取 0 到 455, abc 可以取 0 到 999
    4551000 to 4551999 (1000)
    4541000 to 4541999 (1000)
    4531000 to 4531999 (1000)
    ...
    21000 to   21999 (1000)
    11000 to   11999 (1000)    
    1000 to    1999 (1000)
总共就是 456 * 1000

如果 n = 4561234
    xyz 可以取 0 到 455, abc 可以取 0 到 999
    4551000 to 4551999 (1000)
    4541000 to 4541999 (1000)
    4531000 to 4531999 (1000)
    ...
    1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 234
    4561000 to 4561234 (234 + 1)
总共就是 456 * 1000 + 234 + 1

如果 n = 4563234
xyz 可以取 0 到 455, abc 可以取 0 到 999    
    4551000 to 4551999 (1000)
    4541000 to 4541999 (1000)
    4531000 to 4531999 (1000)
    ...
    1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 999
    4561000 to 4561999 (1000)
总共就是 456 * 1000 + 1000

```java
class Solution {
    public int countDigitOne(int n) {
        int count = 0;
        //依次考虑个位、十位、百位...是 1
        //k = 1000, 对应于上边举的例子
        for (int k = 1; k <= n; k *= 10) { 
            // xyzdabc
            int abc = n % k;
            int xyzd = n / k;
            int d = xyzd % 10;
            int xyz = xyzd / 10;
            count += xyz * k;
            if (d > 1) {
                count += k;
            }
            if (d == 1) {
                count += abc + 1;
            }
            //如果不加这句的话，虽然 k 一直乘以 10，但由于溢出的问题
            //k 本来要大于 n 的时候，却小于了 n 会再次进入循环
            //此时代表最高位是 1 的情况也考虑完成了
            if(xyz == 0){
                break;
            }
        }
        return count;
    }
}
```